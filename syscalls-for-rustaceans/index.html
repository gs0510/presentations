<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Syscalls for Rustaceans!</title>
  <meta name="description" content="Systems programming in Rust!">
  <link rel="stylesheet" href="css/reveal.css">
  <link id="theme" rel="stylesheet" href="css/theme/lengstorf.css">
  <link rel="stylesheet" href="lib/css/github.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
  <script>
    (function (d) {
      var config = {
        kitId: 'fnr1orp',
        scriptTimeout: 3000,
        async: true
      },
        h = d.documentElement, t = setTimeout(function () { h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive"; }, config.scriptTimeout), tk = d.createElement("script"), f = false, s = d.getElementsByTagName("script")[0], a; h.className += " wf-loading"; tk.src = 'https://use.typekit.net/' + config.kitId + '.js'; tk.async = true; tk.onload = tk.onreadystatechange = function () { a = this.readyState; if (f || a && a != "complete" && a != "loaded") return; f = true; clearTimeout(t); try { Typekit.load(config) } catch (e) { } }; s.parentNode.insertBefore(tk, s)
    })(document);

  </script>
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);

  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h1 style="font-size: 80px; width: 110%; margin-left: -5%; margin-top: 80px;">Syscalls for Rustaceans!</h1>
        <p>by Gargi Sharma<br><small><a href="https://twitter.com/gawwrgi">@gawwrgi</a>&nbsp; &nbsp;</small></p>
      </section>

      <section>
        <h2>Follow the slides: <em style="font-size: 97%"><a href="http://tiny.cc/rustrace">tiny.cc/rustrace</a></em>
        </h2>

      </section>

      <section>
        <h1><span class="hugify alright-calm-down-a-little" style="display: block; font-size: 83%">What even is a
            systems programming language?</span></h1>
        <aside class="notes">
          Before I begin talking about syscalls, I want to talk about what even is a systems programming language?
          It's a term you hear a lot when talking about Rust! How Rust is a new systems programming language? What makes
          a programming language suitable for systems programming? So, let's take a tour through history, and talk about
          the evolution of systems programming languages!
        </aside>
      </section>
      <section>
        <h2><em style="font-size: 237%">1970</em>s:<span class="hugify alright-calm-down-a-little">Improving on
            Assembly</span>
        </h2>
        <aside class="notes">
        </aside>
      </section>
      <section>
        <h3> "A <em style="font-size: 137%">system program</em> is <span><br></span> an integrated <em
            style="font-size: 137%">set of<span><br></span>
            subprograms</em> ... <span><br></span>
          <em style="font-size: 137%">exceeding</em> some <span><br></span> threshold of <em
            style="font-size: 137%">size <span><br></span> and/or
            complexity.</em>"</h3>
        <div style="display: flex; justify-content: space-between;">
          <div style="width: 95%">
            <h4>Systems Programming Languages <br>(Bergeron et al. 1972)<br> </h4>

          </div>
        </div>
        <aside class="notes">
          I don’t know who coined the phrase originally, but my searches suggest that serious effort in defining
          “computer systems” started around the early 70s.

          In Systems Programming Languages (Bergeron1 et al. 1972), the authors say: "A system is an integrated set of
          subprograms exceeding some threshold of size or complexity."

          Typical examples are systems for multiprogramming, translating, simulating, managing information, and time
          sharing.


        </aside>
      </section>
      <section>
        <h2><em style="font-size: 137%">1970</em>s:
        </h2>
        <ul>
          <li class="fragment">The system program is likely to be used to support other software programs.</li>
          <li class="fragment">It is designed for continued “production” use rather than a one-shot solution to a single
            applications problem.</li>
          <li class="fragment">A system program requires a certain discipline or structure, both within and between
            modules.</li>
        </ul>
        <aside class="notes">
          The system program is likely to be used to support other software and applications programs, but may also be a
          complete applications package itself.
          It is likely to be continuously evolving in the number and types of features it supports.
          A system program requires a certain discipline, both within and between modules, and is usually designed and
          implemented by more than one person.
          It is designed for continued “production” use rather than a one-shot solution to a single applications
          problem.
          A system program requires a certain discipline or structure, both within and between modules (i.e. ,
          “communication”) , and is usually designed and implemented by more than one person.


        </aside>
      </section>

      <section>
        <h2><em style="font-size: 137%">1970</em>s:</h2>
        <h2> <span style="display: block; font-size: 40%"></span> A language which can be used without undue concern
          for <span class="underlined">bit</span> <span class="underlined">twiddling</span>.
          </span>
        </h2>

        <aside class="notes">
          This definition is fairly agreeable—computer systems are large-scale, long-used, and time-varying. However,
          while this definition is largely descriptive, a key idea in the paper is prescriptive: advocating for the
          separation of low-level languages from systems languages (at the time, contrasting assembly with FORTRAN).

          Such a language should combine the conciseness and readability of high level languages with the space and time
          efficiency and the ability to “get at” machine and operating system facilities obtainable in assembler
          language. Designing, writing, and debugging time should be minimized without imposing unnecessary overhead
          on systems resources.
        </aside>
      </section>

      <section>
        <figure><img src="./images/systems-pyramid.png" alt="">
          <figcaption>Credit: Systems Programming (Donovan 1972)</figcaption>
        </figure>
        <aside class="notes">
          The last entry to consider from 1970s is the paper "Systems Programming" from Donovan and folks.
          1972 was a productive year ! -_-

          What is systems programming? You may visualize a computer as some sort of beast that obeys all commands. It
          has been said that computers are basically people made out of metal or, conversely, people are computers made
          out of flesh and blood. However, once we get close to computers, we see that they are basically machines that
          follow very specific and primitive instructions. In the early days of computers, people communicated with them
          by on and off switches denoting primitive instructions. Soon people wanted to give more complex instructions.
          For example, they wanted to be able to say X = 30 * Y; given that Y = 10, what is X? Present day computers
          cannot understand such language without the aid of systems programs. Systems programs (e.g. compilers,
          loaders, macro processors, operating systems) were developed to make computers better adapted to the needs of
          their users. Further, people wanted more assistance in the mechanics of preparing their programs.
        </aside>
      </section>

      <section>
        <h2><em style="font-size: 237%">1990</em><span>s:</span><span class="hugify alright-calm-down-a-little">Rise
            of
            Scripting languages</span>
        </h2>
        <aside class="notes">
          In the 70s and 80s, it seems like most researchers saw systems programming usually as a contrast to assembly
          programming. There simply were no other good tools to build systems
          However, in the mid 90s, a major sea change occurred in programming languages with the rise of
          dynamically-typed scripting languages.


        </aside>
      </section>

      <section>
        <h2><em style="font-size: 137%">1990</em>s:</h2>
        <h2><span style="display: block; font-size: 70%">Rise of Scripting languages</span></h2>
        <ul>
          <li class="fragment">Bash, languages like Perl, Python, Ruby, Javascript etc. worked their way into
            the mainstream.</li>
          <li class="fragment">Systems programming languages designed to build more primitive computer elements.</li>
          <li class="fragment">Scripting languages are designed for <span class="underlined">gluing</span>.</li>
        </ul>
        <aside class="notes">
          “Scripting: Higher Level Programming for the 21st Century” (Ousterhout 1998)
          Scripting languages are designed for different tasks than system programming languages, and this leads to
          fundamental differences in the languages. System programming languages were designed for building data
          structures and algorithms from scratch, starting from the most primitive computer elements such as words of
          memory. In contrast, scripting languages are designed for gluing: they assume the existence of a set of
          powerful components and are intended primarily for connecting components together.
          System programming languages are strongly typed to help manage complexity, while scripting languages are
          typeless to simplify connections between components and provide rapid application development.
        </aside>
      </section>


      <section>
        <h2><em style="font-size: 237%">2010</em>s:<span class="hugify alright-calm-down-a-little"
            style="font-size: 137%">Boundaries
            Blur</span>
        </h2>
        <aside class=" notes">
          massive engineering resources poured into JIT compilers for both static languages (e.g. Java’s HotSpot) and
          dynamic language (e.g. Lua’s LuaJIT, Javascript’s V8, Python’s PyPy) have made their performance competitive
          with traditional systems programming languages (C, C++).

          ava (1995) and C# (2000) turned into the titans we know today. While these two aren’t traditionally
          considered “systems programming languages,” they have been used to design many of the world’s biggest software
          systems. Ousterhout even explicitly mentioned “in the Internet world that is taking shape now, Java is used
          for system programming.”
        </aside>
      </section>


      <section>
        <h2><em style="font-size: 237%">2010</em>s:</h2>
        <h2><span style="display: block; font-size: 70%">Boundaries Blur</span></h2>
        <ul>
          <li class="fragment">Dropbox were able to build surprisingly large and scalable systems on just Python.</li>
          <li class="fragment">Javascript is used to render real-time, complex UIs in billions of web pages.</li>
          <li class="fragment">Gradual typing has gained steam in Javascript, Python, etc. enabling a transition from
            “prototype” code to “production” code.</li>
        </ul>
        <aside class="notes">
          Large-scale distributed systems like Spark are written in Scala. New programming languages like Julia, Swift,
          and Go continue to push performance boundaries on garbage-collected languages.
        </aside>
      </section>

      <section>
        <h2> <span style="display: block; font-size: 140%">What is a</span> <em style="font-size: 140%">systems
            programming language </em><span style="display: block; font-size: 140%">today?</span>

        </h2>
        <aside class="notes">
          languages in the category of C, C++, Rust, and D are distinguished in terms of their level of abstraction from
          the machine. These languages expose details of the underlying hardware like memory allocation/layout and
          fine-grained resource management.

          when you have an efficiency problem, how much freedom do you have to solve it? The wonderful part of low-level
          programming languages is that when you identify an inefficiency, it is within your power to eliminate the
          bottleneck by careful control over machine details.

          In the same way static types provide more confidence like “these two things I’m trying to add are definitely
          integers,” low-level languages provide more confidence that “this code will execute on the machine as I
          specified.”

          Low-level programmers should seek to understand what ideas in systems design could be adapted to deal with the
          reality of modern hardware.

          Rust community has been exceedingly innovative in this respect, looking at how good software design/functional
          programming principles can be applied to low-level problems (e.g. futures, error handling, or of course memory
          safety).

        </aside>
      </section>

      <section>
        <h2> <span style="display: block; font-size: 140%">Where does</span> <em style="font-size: 140%">Rust
          </em><span style="display: block; font-size: 140%">shine?</span>
        </h2>
        <aside class="notes">
          Its headline domain is systems programming, an area most prominently occupied by C & C++. Yet the boundary of
          that domain is quite porous. Historically, it would have covered software such as operating systems,
          compilers, interpreters, file systems and device drivers. Now, it would also include web browsers and other
          software, even if it are user-facing.

          Despite many advances in programming languages, clean-slate operating systems, hypervisors, key-value stores,
          web servers, network and storage frameworks are still developed in C, a programming language that is in many
          ways closer to assembly than to a modern high-level language. Today, the price of running unsafe code is high…
          Why are we still using C?

          We should also consider the additional benefits of consider additional benefits for systems programming that
          are enabled by Rust’s type system: software fault isolation (SFI), program analysis – especially static
          information flow control (IFC), and safe traversal of pointer-linked data structures which enables automation
          of tasks such as checkpointing.
        </aside>
      </section>


      <section>
        <h3 style="margin-bottom: 0; font-size: 180%"><span>Systems programming is </span>
          <span><br></span><span>programming
            where</span> <span><br></span> <span>you spend
            more time </span>
          <span style="display: block; margin-top: 0.05em; font-size: 120%"><em>reading man
              pages</em><span>
              than</span>
            <em>reading the internet.</em></span></h3>
        <div style="display: flex; justify-content: space-between;">
          <div style="width: 95%">
            - Kamal Mahrubi </h4>

          </div>
        </div>
        <aside class="notes">
          But you can throw everything I talked about last 10 minutes out of the window and systems-programming is
          when you spend more time looking at man pages than you do the internet.
        </aside>

      </section>


      <section>
        <h2> <span style="display: block; font-size: 140%">Writing our own</span> <em style="font-size: 140%">strace!
          </em>

        </h2>
        <aside class="notes">
          This is the second part of the talk. In this part, we will learn how to write our own strace! Before
          we begin talking about strace, let's talk about what are system calls?!
        </aside>
      </section>

      <section>
        <figure><img src="./images/syscalls.png" alt="">
        </figure>
        <h2> <span class="fragment"> <em style="font-size: 140%">System Calls!
            </em></span>
        </h2>
        <aside class="notes">
          When you are running an application, and you want to do something that might seem trivial,
          for example, reading from a file, you still need to talk to the operating system, because
        </aside>
      </section>

      <section>
        <h2> <em style="font-size: 140%">Syscalls!</em></h2>
        <h4><span class="fragment">Around 330 system calls in Linux:</h4>
        <ul>
          <li class="fragment">File Access - <font color="#800020">read</font>, <font color="#800020">write</font>,
            <font color="#800020">open</font>, <font color="#800020">close</font>, etc.</li>
          <li class="fragment">Process Control - <font color="#800020">wait</font>, <font color="#800020">waitpid</font>
            , <font color="#800020">kill</font>, etc.</li>
          <li class="fragment">Network Access - <font color="#800020">socket</font>, <font color="#800020">getsockpt
            </font>, <font color="#800020">listen</font>, etc.</li>
        </ul>
        <aside class="notes">
          Some esoteric, some widespread.
          Some system calls are posix system calls, some are not.
          POSIX is a family of standards specified by the IEEE Computer Society for maintaining compatibility
          between
          operating systems.

        </aside>
      </section>

      <section>
        <h2 style="font-size: 99%">What happens when a syscall occurs?</h2>
        <figure><img src="./images/syscalls-actions.png" alt="">
        </figure>
        <aside class="notes">
          A request from an application program for the operating system to perform some hardware action on behalf of
          the application. System calls are initiated with a software interrupt assembly language instruction. The
          argument to the interrupt instruction is a number, which corresponds to the index of an array in the OS kernel
          with pointers to the functions that provide the requested service.
        </aside>
      </section>



      <section>
        <h2 style="font-size: 204%">Making a syscall.</h2>
        <figure><img src="./images/syscalls-registers.png" alt="">
        </figure>
        <ul>
          <li class="fragment">Setup register with syscall number & parameters.</li>
          <li class="fragment">Send a trap to kernel.</li>
          <li class="fragment">Result stored in register.</li>
        </ul>
        <aside class="notes">
          Some system calls are posix system calls, some are not.
          POSIX is a family of standards specified by the IEEE Computer Society for maintaining compatibility between
          operating systems.

        </aside>
      </section>

      <section>
        <h2> <span style="display: block; font-size: 140%">What is</span> <em style="font-size: 140%">strace?
          </em>
        </h2>
        <ul>
          <li class="fragment">A diagnostic, debugging and instructional userspace utility for Linux.</li>
          <li class="fragment">Invaluable for solving problems with programs for which the source is not readily
            available.</li>
        </ul>
        <aside class="notes">


        </aside>
      </section>

      <section>
        <h2 style="font-size: 204%">Writing our own strace.</h2>
        <ul>
          <li class="fragment">How to observe another process?</li>
          <li class="fragment">How to trap a system call?</li>
          <li class="fragment">How to fetch register values?</li>
        </ul>
        <aside class="notes">


        </aside>
      </section>

      <section>
        <h2>How to observe a process?</h2>
        <h4><em class="fragment">
            <font color="#800020">ptrace!!</font>
          </em></h4>
        <em class="fragment">
          <figure><img src="./images/ptrace.png" alt=""></figure>
        </em>
        <aside class="notes">
          The ptrace mechanism makes it possible for strace to interrupt the traced process every time a system call is
          invoked, capture the call, decode it, and then resume the execution of the traced process. The challenge is
          that, as you may know, every time a system call is invoked (eg. open, read, write, close), a transition from
          user level to kernel level is required – this is known as a context switch. This is accomplished in different
          ways depending on the CPU family and model, but it tends to be complex and relatively slow.
        </aside>
      </section>

      <section>
        <h2>How to observe a process?</h2>
        <pre><code>
        let output = cmd.before_exec(ptrace::traceme());
          
        let mut child = cmd.spawn();
        </code></pre>
        <aside class="notes">
        </aside>
      </section>


      <section>
        <h2>How to trap a system call?</h2>
        <em class="fragment">
          <figure><img src="./images/sigtrap.png" alt=""></figure>
        </em>
        <aside class="notes">
        </aside>
      </section>

      <section>
        <h2>How to trap a system call?</h2>
        <pre><code>
                    ptrace(
                      Request::PTRACE_SYSCALL,
                      pid,
                      ptr::null_mut(),
                      ptr::null_mut(),
                    );
                    </code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section>
        <h2>How to fetch register values?</h2>
        <pre><code>
        let res = ptrace::ptrace(
          Request::PTRACE_GETREGS,
          pid,
          PT_NULL as *mut c_void,
          &mut regs as *mut _ as *mut c_void,
        );
        </code></pre>
        <aside class="notes">
        </aside>
      </section>

      <section>
        <h2>You can find the code on Github: <a href="https://github.com/gs0510/rustrace">rustrace</a> </h2>

      </section>

      <section>
        <h2><strong class="hugify">DEMO!</strong></h2>
      </section>

      <section>
        <h1 class="no-margin">Thanks!</h1>
      </section>
      <section class="u--align-left resourcetext">
        <h4>Resources</h4>
        <ol>
          <li><a href="https://www.youtube.com/watch?v=01w7viEZzXQ">A Go Programmer's Guide to Syscalls</a></li>
          <li><a href="https://bit.ly/2Z7iJQP">Rust implementation of glibc</a></li>
          <li><a href="https://bit.ly/2ZaxPoy">System call table for Linux
              x86</a></li>
          <li><a href="http://willcrichton.net/notes/systems-programming/">What is systems programming really?</a></li>
          <li><a href="https://www.tcl.tk/doc/scripting.html">Scripting: Higher Level Programming
              for the 21st Century</a></li>
          <li><a href="https://bit.ly/1MvkwUS">
              Rust + nix = easier unix systems programming </a> </li>
          <li><a href="https://bit.ly/2P0e3by">
              Slide theme from @jlengstorf </a></li>
        </ol>
      </section>
    </div>
  </div>

  <div class="hashtag">
    <p>Tweet: <a href="https://twitter.com/gawwrgi">@gawwrgi </a></p>
  </div>

  <script src="lib/js/head.min.js">
  </script>
  <script src="js/reveal.js"></script>
  <script>
    // We'll reference this element several times
    var htmlElement = document.querySelector('html');

    // Bind a function to the `fragmentshown` event so we can do some custom bits
    Reveal.addEventListener('fragmentshown', function (event) {
      var fragment = event.fragment;

      // For fragments with a `dim-the-lights` class, we dim the lights
      if (fragment.classList && fragment.classList.contains('dim-the-lights')) {
        htmlElement.classList.add('blackout');
      }
    });

    // Define a quick function to remove the blackout class from the document
    var removeBlackout = function removeBlackout() {
      return htmlElement.classList.remove('blackout');
    };

    // Bind the function to Reveal actions so we get the desired effect
    Reveal.addEventListener('fragmenthidden', removeBlackout);
    Reveal.addEventListener('slidechanged', removeBlackout);

    Reveal.addEventListener('slidechanged', event => {
      if (event.currentSlide.classList.contains('dim')) {
        htmlElement.classList.add('blackout');
      }
    });

    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      history: true,
      transition: 'none',
      backgroundTransition: 'none',

      // More info https://github.com/hakimel/reveal.js#dependencies
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
      ]
    });

  </script>
</body>

</html>