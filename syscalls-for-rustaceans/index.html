<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Syscalls for Rustaceans!</title>
  <meta name="description" content="Systems programming in Rust!">
  <link rel="stylesheet" href="css/reveal.css">
  <link id="theme" rel="stylesheet" href="css/theme/lengstorf.css">
  <link rel="stylesheet" href="lib/css/github.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
  <script>
    (function (d) {
      var config = {
        kitId: 'fnr1orp',
        scriptTimeout: 3000,
        async: true
      },
        h = d.documentElement, t = setTimeout(function () { h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive"; }, config.scriptTimeout), tk = d.createElement("script"), f = false, s = d.getElementsByTagName("script")[0], a; h.className += " wf-loading"; tk.src = 'https://use.typekit.net/' + config.kitId + '.js'; tk.async = true; tk.onload = tk.onreadystatechange = function () { a = this.readyState; if (f || a && a != "complete" && a != "loaded") return; f = true; clearTimeout(t); try { Typekit.load(config) } catch (e) { } }; s.parentNode.insertBefore(tk, s)
    })(document);

  </script>
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);

  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h1 style="font-size: 80px; width: 110%; margin-left: -5%; margin-top: 80px;">Syscalls for Rustaceans!</h1>
        <p>by Gargi Sharma<br><small><a href="https://twitter.com/gawwrgi">@gawwrgi</a>&nbsp; &nbsp;</small></p>
      </section>
      <section>
        <h1><span class="hugify alright-calm-down-a-little" style="display: block; font-size: 83%">What even is a
            systems programming language?</span></h1>
      </section>
      <section>
        <h2><em style="font-size: 237%">1970</em>s:<span class="hugify alright-calm-down-a-little">Improving on
            Assembley</span>
        </h2>
        <aside class="notes">
        </aside>
      </section>
      <section>
        <h3> "A system program is an integrated set of subprograms, together forming a whole greater than the sum of
          its parts, and
          exceeding some threshold of size and/or complexity."</h3>
        <div style="display: flex; justify-content: space-between;">
          <div class="fragment" style="width: 95%">
            <h4>Systems Programming Languages <br>(Bergeron et al. 1972)<br> </h4>

          </div>
        </div>
        <aside class="notes">
          Typical examples are systems for multiprogramming, translating, simulating, managing information, and time
          sharing.


        </aside>
      </section>
      <section>
        <h2><em style="font-size: 137%">1970</em>s:
        </h2>
        <ul>
          <li class="fragment">The system program is likely to be used to support other software programs.</li>
          <li class="fragment">It is designed for continued “production” use rather than a one-shot solution to a single
            applications problem.</li>
          <li class="fragment">A system program requires a certain discipline or structure, both within and between
            modules.</li>
        </ul>
        <aside class="notes">
          The system program is likely to be used to support other software and applications programs, but may also be a
          complete applications package itself.
          It is likely to be continuously evolving in the number and types of features it supports.
          A system program requires a certain discipline, both within and between modules, and is usually designed and
          implemented by more than one person.
          It is designed for continued “production” use rather than a one-shot solution to a single applications
          problem.
          A system program requires a certain discipline or structure, both within and between modules (i.e. ,
          “communication”) ,
          and is usually designed and implemented by more than one person.


        </aside>
      </section>

      <section>
        <h2><em style="font-size: 137%">1970</em>s:</h2>
        <h2> <span style="display: block; font-size: 40%"></span> A language which can be used without undue concern
          for <span class="underlined">bit</span> <span class="underlined">twiddling</span>.
          </span>
        </h2>

        <aside class="notes">
          This definition is fairly agreeable—computer systems are large-scale, long-used, and time-varying. However,
          while this definition is largely descriptive, a key idea in the paper is prescriptive: advocating for the
          separation of low-level languages from systems languages (at the time, contrasting assembly with FORTRAN).

          Such a language should combine the conciseness and readability of high ,, languages with the space and time
          efficiency and the ability to “get at” machine and operating system facilities obtainable in assembler
          language. Designing, writing, and debugging time should be minimized without imposing unnecessary overhead
          on
          systems resources.

        </aside>
      </section>

      <section>
        <figure><img src="./images/systems-pyramid.png" alt="">
          <figcaption>Credit: Systems Programming (Donovan 1972)</figcaption>
        </figure>
        <aside class="notes">
          What is systems programming? You may visualize a computer as some sort of beast that obeys all commands. It
          has been said that computers are basically people made out of metal or, conversely, people are computers made
          out of flesh and blood. However, once we get close to computers, we see that they are basically machines that
          follow very specific and primitive instructions. In the early days of computers, people communicated with them
          by on and off switches denoting primitive instructions. Soon people wanted to give more complex instructions.
          For example, they wanted to be able to say X = 30 * Y; given that Y = 10, what is X? Present day computers
          cannot understand such language without the aid of systems programs. Systems programs (e.g. compilers,
          loaders, macro processors, operating systems) were developed to make computers better adapted to the needs of
          their users. Further, people wanted more assistance in the mechanics of preparing their programs.


        </aside>
      </section>

      <section>
        <h2><em style="font-size: 237%">1990</em><span>s:</span><span class="hugify alright-calm-down-a-little">Rise
            of
            Scripting languages</span>
        </h2>
        <aside class="notes">
          “Scripting: Higher Level Programming for the 21st Century” (Ousterhout 1998)
          Scripting languages are designed for different tasks than system programming languages, and this leads to
          fundamental differences in the languages. System programming languages were designed for building data
          structures and algorithms from scratch, starting from the most primitive computer elements such as words of
          memory. In contrast, scripting languages are designed for gluing: they assume the existence of a set of
          powerful components and are intended primarily for connecting components together.
          System programming languages are strongly typed to help manage complexity, while scripting languages are
          typeless to simplify connections between components and provide rapid application development.


        </aside>
      </section>

      <section>
        <h2><em style="font-size: 137%">1990</em>s:</h2>
        <h2><span style="display: block; font-size: 70%">Rise of Scripting languages</span></h2>
        <ul>
          <li class="fragment">Bash, languages like Perl, Python, Ruby, Javascript etc. worked their way into
            the mainstream.</li>
          <li class="fragment">Systems programming languages designed to build more primitive computer elements.</li>
          <li class="fragment">Scripting languages are designed for <span class="underlined">gluing</span>.</li>
        </ul>
        <aside class="notes">
          “Scripting: Higher Level Programming for the 21st Century” (Ousterhout 1998)
          Scripting languages are designed for different tasks than system programming languages, and this leads to
          fundamental differences in the languages. System programming languages were designed for building data
          structures and algorithms from scratch, starting from the most primitive computer elements such as words of
          memory. In contrast, scripting languages are designed for gluing: they assume the existence of a set of
          powerful components and are intended primarily for connecting components together.
          System programming languages are strongly typed to help manage complexity, while scripting languages are
          typeless to simplify connections between components and provide rapid application development.
        </aside>
      </section>


      <section>
        <h2><em style="font-size: 237%">2010</em>s:<span class="hugify alright-calm-down-a-little"
            style="font-size: 137%">Boundaries
            Blur</span>
        </h2>
        <aside class=" notes">
          massive engineering resources poured into JIT compilers for both static languages (e.g. Java’s HotSpot) and
          dynamic language (e.g. Lua’s LuaJIT, Javascript’s V8, Python’s PyPy) have made their performance competitive
          with traditional systems programming languages (C, C++).
        </aside>
      </section>


      <section>
        <h2><em style="font-size: 237%">2010</em>s:</h2>
        <h2><span style="display: block; font-size: 70%">Boundaries Blur</span></h2>
        <ul>
          <li class="fragment">Dropbox were able to build surprisingly large and scalable systems on just Python.</li>
          <li class="fragment">Javascript is used to render real-time, complex UIs in billions of web pages.</li>
          <li class="fragment">Gradual typing has gained steam in Javascript, Python, etc. enabling a transition from
            “prototype” code to “production” code.</li>
        </ul>
        <aside class="notes">
          Large-scale distributed systems like Spark are written in Scala. New programming languages like Julia, Swift,
          and Go continue to push performance boundaries on garbage-collected languages.
        </aside>
      </section>

      <section>
        <h2> <span style="display: block; font-size: 140%">What is a</span> <em style="font-size: 140%">systems
            programming language </em><span style="display: block; font-size: 140%">today?</span>

        </h2>
        <aside class="notes">
          languages in the category of C, C++, Rust, and D are distinguished in terms of their level of abstraction from
          the machine. These languages expose details of the underlying hardware like memory allocation/layout and
          fine-grained resource management.

          when you have an efficiency problem, how much freedom do you have to solve it? The wonderful part of low-level
          programming languages is that when you identify an inefficiency, it is within your power to eliminate the
          bottleneck by careful control over machine details.

          In the same way static types provide more confidence3 like “these two things I’m trying to add are definitely
          integers,” low-level languages provide more confidence that “this code will execute on the machine as I
          specified.”

          Low-level programmers should seek to understand what ideas in systems design could be adapted to deal with the
          reality of modern hardware.

          Rust community has been exceedingly innovative in this respect, looking at how good software design/functional
          programming principles can be applied to low-level problems (e.g. futures, error handling, or of course memory
          safety).

        </aside>
      </section>


      <section>
        <h3 style="margin-bottom: 0; font-size: 180%">Systems programming is programming where you spend more time<span
            style="display: block; margin-top: 0.05em; font-size: 120%"><em>reading man pages</em><span
              style="font-size: 108%"> than</span>
            <em>reading the internet.</em></span></h3>
        <div style="display: flex; justify-content: space-between;">
          <div style="width: 95%">
            - Kamal Mahrubi </h4>

          </div>
        </div>
      </section>



      <section>
        <h2>Being the team’s<strong class="hugify">auditor</strong>feels... less good</h2>
        <aside class="notes">
          Digging into the underlying causes of team inefficiencies isn’t typically
          considered a good time. It’s hard to communicate the business value of it,
          and typically management will push back if you try to focus on underlying
          problems instead of putting out immediate fires. There are not usually
          rewards, recognition, or even gratitude for pursuing this option. This is
          not glamorous or high-profile work.

        </aside>
      </section>
      <section>
        <h2>There’s just one<strong class="hugify">problem</strong></h2>
      </section>
      <section>
        <h2><span class="hugify alright-calm-down-a-little">Rockstars</span>don’t get <span class="underlined">days
            off</span></h2>
        <aside class="notes">
          If you’re the only reason your team hits its deadlines, that makes it
          pretty tough to take a vacation.

        </aside>
      </section>
      <section class="light-text dim" data-background-image="./images/make-the-right-thing-the-easy-thing/bus.gif">
        <h2>What is your code’s<span style="display: block; font-size: 170%">bus factor?</span></h2>
        <aside class="notes">
          It’s common to hear developers talk about the “bus factor” — also called
          the “truck number” or “lottery number” — of a given codebase. It’s
          intended to point out the fragility of a project: how many people have to
          get hit by a bus before no one is left that knows how it works?
          <br><br>
          That feels a little too negative and alarmist to me, though. So what about
          a more positive (and realistic) term for it?

        </aside>
      </section>
      <section class="light-text dim"
        data-background-image="./images/make-the-right-thing-the-easy-thing/vacation.webp">
        <h2>What is your code’s<span class="underlined"
            style="display: block; font-size: 210%; line-height: 0.9">vacation</span><span
            style="display: block; font-size: 170%">tolerance?</span></h2>
        <aside class="notes">
          On any team, we need everyone to have the ability to take time off. So
          instead of talking about the bus factor, talk about how easily any given
          person can go on vacation. Could two people go on vacation without
          stalling the rest of the team? Ideally, every team member should be pretty
          effective even if the entire team took time off.

        </aside>
      </section>

      <section>
        <h2 style="font-size: 6.5rem">We need to do<em
            style="display: block; font-size: 220%; line-height: 0.8">better</em>for our teams</h2>
      </section>
      <section>
        <h1><span style="font-size: 46%">We need to fix the</span><em class="hugify"
            style="margin-top: 0.05em; line-height: 0.7">real</em>problem</h1>
        <aside class="notes">
          Yes, it’s not all that glamorous, but if we really want to create teams
          that run well, we need to fix the underlying problems that created a need
          for a rockstar in the first place.

        </aside>
      </section>
      <section>
        <h1><span style="font-size: 65%">We need to create a</span><em
            style="display: block; font-size: 170%">Process</em></h1>
      </section>
      <section>
        <h4>...wait, what?</h4>
      </section>
      <section>
        <h3>What <span class="underlined">slows teams down</span>?</h3>
        <ul>
          <li class="fragment">Lack of confidence in ability, knowledge, or autonomy</li>
          <li class="fragment">Lack of clarity about the goal of a given project</li>
        </ul>
        <aside class="notes">
          When teams run poorly, in my experience that largely comes from people
          either lacking confidence — they’re not confident they know how to do the
          thing, they’re not confident they’re allowed to do the thing without
          sign-off, they’re not confident that someone else on the team won’t go in
          and rewrite their code later — or lacking clarity: they’re not clear on
          what’s expected of them; they’re not clear on who the stakeholders are;
          they’re not clear on what “done” looks like.

        </aside>
      </section>
      <section>
        <h3 style="margin-bottom: 0; font-size: 180%">A good process creates<span
            style="display: block; margin-top: 0.05em; font-size: 210%"><em>confidence</em><span
              style="font-size: 118%">&amp; <em>clarity</em></span></span></h3>
        <h4 class="no-margin"> <span class="fragment">+ <em>autonomy</em> </span><span class="fragment">+ <em>trust</em>
          </span><span class="fragment">+ <em>ownership</em> </span><span class="fragment">+
            <em>safety</em></span><br><span class="fragment">+ other buzzwords meaning “happy team”</span></h4>
        <aside class="notes">
          When a team feels confident, they can act without feeling like they need
          to seek approval — and that’s a good thing, because the parameters for
          what someone can do without approval are clearly defined in the process.
          Since the goals and accountability chains are crystal clear, no one needs
          to wonder where to start or what to work on next. This leads to a team of
          people who trust each other because the proper guard rails are in place.
          And because there’s trust, team members feel real ownership in the
          projects and process: they have a voice, and that voice is being heard.
          And because the process defines what is and isn’t acceptable, the whole
          team can feel safe to bring up potential issues. Usually, though, a good
          process means the issues get caught <em>way</em> earlier, before they become
          huge problems. All of this leads to the kind of high-collaboration,
          high-functioning environment every management consultant dreams about.

        </aside>
      </section>
      <section>
        <h3 style="font-size: 180%">A good process creates<span
            style="display: block; margin-top: 0.05em; font-size: 145%"><em>stronger teams</em></span></h3>
        <ul>
          <li class="fragment">No one is a bottleneck</li>
          <li class="fragment">Each dev can make decisions independently</li>
          <li class="fragment">Knowledge is shared and documented</li>
          <li class="fragment">No chaos if devs take vacation, get promoted, or quit</li>
        </ul>
      </section>
      <section>
        <h1 style="font-size: 360%">How can we<em style="display: block; font-size: 180%">create</em><span
            style="display: block; font-size: 73%; line-height: 0.8">solid processes?</span></h1>
      </section>
      <section>
        <h3 style="font-size: 180%">A good process needs</h3>
        <ul>
          <li class="fragment">Excellent onboarding and documentation</li>
          <li class="fragment">Ongoing internal education and training</li>
          <li class="fragment">Frequent code reviews and coaching</li>
          <li class="fragment">Comprehensive test suites</li>
          <li class="fragment">Internally consistent style and quality guidelines</li>
        </ul>
        <aside class="notes">
          A high-functioning team’s process will be so solid that new team members
          are basically painting by numbers to get started. A good measuring stick
          for this is whether or not you can get a new hire up and running fast
          enough to have them commit non-trivial code to production on the first
          day. The team should be documenting any repeatable process so it can be
          quickly referenced by everyone else. This gets driven home by solid
          coaching, and the best practices are enforced by comprehensive test suites
          and a set of guidelines for code style and quality.

        </aside>
      </section>
      <section>
        <h1 style="font-size: 290%">“I’ve tried this!<strong style="display: block; font-size: 222%">No
            one</strong><span style="font-size: 120%">will listen!”</span></h1>
        <aside class="notes">
          I know, I just said all of the worst things. Even the most
          well-intentioned teams typically try and fail to adopt things like
          documentation. It might work for a while, but then it gets busy, or people
          get comfortable and forget, and ultimately the team’s best practices
          become more theoretical than practical.

        </aside>
      </section>
      <section>
        <h2 style="font-size: 300%">Why processes<strong style="display: block; font-size: 383%">fail</strong></h2>
      </section>
      <section>
        <h1 style="font-size: 670%">Know<small
            style="display: block; color: inherit; font-size: 45%; line-height: 0.7; margin-bottom: 0.125em">vs</small><em
            style="font-size: 145%">feel</em></h1>
      </section>
      <section>
        <h3>The Rider and The Elephant</h3>
        <figure><img src="./images/make-the-right-thing-the-easy-thing/rider-elephant.jpg"
            alt="The elephant and the rider, by Kristin Noelle.">
          <figcaption>Credit: <a href="https://www.etsy.com/shop/SacredLoom">Kristin Noelle</a></figcaption>
        </figure>
        <aside class="notes">
          Chip and Dan Heath have written extensively about behavioral change, and a
          concept they use frequently is “the elephant and the rider”. We’re all
          pretty rational and capable of thinking through long-term benefits —
          that’s the rider. But there’s this other set of urges that frequently
          overpower our rationality in favor of instant gratification — that’s
          the elephant.

        </aside>
      </section>
      <section><img class="no-border" src="./images/make-the-right-thing-the-easy-thing/book-switch.png"
          alt="Book cover for Switch, by Chip and Dan Heath.">
        <aside class="notes">This is a concept that’s explored deeply in their book, <em>Switch</em>,
          which I’d highly recommend reading.

        </aside>
      </section>
      <section>
        <h2 style="font-size: 204%">Syscalls for<em style="display: block; font-size: 147%">Rustaceans!</em>
        </h2>
        <h4><span class="fragment">By focusing on four core values:</span><br><em class="fragment">Emotional Rewards
          </em><span class="fragment">+ <em>Automation</em></span><br><span class="fragment">+ <em>Simplification
            </em></span><span class="fragment">+ <em>Yak Shaving</em></span></h4>
        <aside class="notes">
          Being right isn’t enough. If we could solve human problems with logic,
          there wouldn’t be any problems. The rider can only take us so far; if we
          want to make real, lasting change, we need to appeal to the elephant. This
          means that we need to make any new processes more emotionally rewarding
          than the old way of doing things.

        </aside>
      </section>
      <section>
        <h3 style="font-size: 200%; text-align: left"><em
            style="display: inline-block; vertical-align: middle; width: 1.2ch; font-size: 160%; text-align: center">E</em>motional
          Rewards<br><span class="fragment"><em
              style="display: inline-block; vertical-align: middle; width: 1.2ch; font-size: 160%; text-align: center">A</em>utomation</span><br><span
            class="fragment"><em
              style="display: inline-block; vertical-align: middle; width: 1.2ch; font-size: 160%; text-align: center">S</em>implification</span><br><span
            class="fragment"><em
              style="display: inline-block; vertical-align: middle; width: 1.2ch; font-size: 160%; text-align: center">Y</em>ak
            Shaving</span></h3>
      </section>
      <section>
        <h4 style="margin-bottom: 0.125em">Make the Right Thing the Easy Thing: part 1</h4>
        <h1 class="no-margin"><em style="font-size: 120%">Emotional<span
              style="font-size: 125%; line-height: 0.75">Rewards</span></em></h1>
        <ul>
          <li class="fragment">Less effort required to do things the new way</li>
          <li class="fragment">Immediate praise and positive feedback</li>
          <li class="fragment">Public recognition and gratitude</li>
        </ul>
        <aside class="notes">
          One of the most rewarding things is to make people more efficient — it
          feels really good to do great work ahead of schedule, so we should try to
          make sure that every process we introduce feels like an upgrade. Some
          processes require extra work, though, so we should make sure to frequently
          and immediately praise great work from the team. When someone follows the
          process, reinforce that behavior by thanking them personally. Remember, it
          never sucks to hear you’re doing a good job, and usually we have to live
          with “no news is good news”; offer positive feedback early and often. When
          there’s a team meeting or a company all-hands, recognize the team publicly
          for doing good work. It’s a small effort, but it goes a long way.

        </aside>
      </section>
      <section>
        <blockquote class="photo-quote">
          <div class="photo"><img src="./images/make-the-right-thing-the-easy-thing/marisa.jpg" alt="Marisa Morby">
          </div>
          <div class="quote">
            <p>“Very few things at work feel better than the validation of other people praising your contributions in
              public.”<strong>Marisa Morby<small>Product Manager, Gatsby</small></strong></p>
          </div>
        </blockquote>
        <aside class="notes">
          We often don’t give people praise because it feels weird to compliment
          people. And maybe we’re more intrinsically motivated and don’t place the
          same importance on validation, but here’s the thing: telling someone they
          did a good job when you see good work <em>never</em> hurts; <em>not</em> telling
          someone they did a good job can potentially lead to them feeling like
          they’re doing poorly. [Tell Marisa and Mike story.]

        </aside>
      </section>
      <section>
        <blockquote class="photo-quote">
          <div class="photo"><img src="./images/jason-lengstorf.jpg" alt="Jason Lengstorf."></div>
          <div class="quote">
            <p>“It doesn’t matter how objectively correct your solution is; it only matters if people will use it.”</p>
            <strong>Me, just now</strong>
          </div>
        </blockquote>
        <aside class="notes"></aside>
      </section>
      <section>
        <h4 style="margin-bottom: 0.125em">Make the Right Thing the Easy Thing: part 2</h4>
        <h1 class="no-margin"><em style="font-size: 105%">Automation</em></h1>
        <ul>
          <li class="fragment">Set up CI/CD (e.g. Travis, Jenkins) for tests</li>
          <li class="fragment">Run and commit Prettier automatically</li>
          <li class="fragment">Use ESLint, Danger.js, etc. to catch quality issues</li>
          <li class="fragment">Automate code coverage checks</li>
          <li class="fragment">Use semantic-release for versioning and releases</li>
        </ul>
        <aside class="notes">
          Automation is a great way to hit that efficiency emotional reward. Take
          something that sucks (like deploying and testing changes) and automate it.
          Once the automation is in place, it’s relatively easy to extend the
          automation to do more things, like automatically fix style issues, check
          for known anti-patterns with ESLint, check for internal issues using
          something like Danger.js, enforce code coverage standards, or even
          automatically deploy new versions of your app.

        </aside>
      </section>
      <section>
        <h2 style="font-size: 250%"><span style="font-size: 130%">Don’t fail on</span><em
            style="display: block; font-size: 320%; line-height: 0.8">style</em><span class="fragment">Just <span
              class="underlined">use Prettier</span></span></h2>
        <aside class="notes">
          A surefire way to undermine any automated process is to make it nitpicky.
          Don’t fail a PR on something like missing semicolons or formatting; just
          run Prettier and autocommit the result to the PR. If team members have to
          jump through annoying hoops to appease the automations, they WILL find a
          way to work around them (like prettierignore).

        </aside>
      </section>
      <section>
        <h4 class="no-margin">Tired:</h4>
        <h1>Code <strong>Cops</strong></h1>
        <h1>👮‍♀️ 👮🏽‍♂️</h1>
        <aside class="notes">
          Earlier, I talked about how it’s not glamorous to be the team’s auditor.
          Most of that comes from the fact that it sucks to have to follow people
          around and hassle them about things like code style, test coverage, and
          other things that we all know we should be doing, but often get lazy
          about. Being the team’s code cop starts to feel a lot like being a parent
          nagging your kids to clean their rooms.

        </aside>
      </section>
      <section>
        <h4 class="no-margin">Wired:</h4>
        <h1>Code <em>Bots</em></h1>
        <h1>🤖 🤖</h1>
        <aside class="notes">
          However, if we can get a robot in there to do the nagging, it gets a lot
          easier. There’s nothing emotional or judgmental about an automated
          process — no one’s code gets preferential treatment, and the rules are
          exactly the same for everyone, regardless of experience or title. Plus, no
          one needs to be the auditor; the things the team decides are important get
          checked consistently and automatically every single time someone opens a
          PR. This practice alone will avoid mountains of technical debt.

        </aside>
      </section>
      <section>
        <h4 style="margin-bottom: 0.125em">Make the Right Thing the Easy Thing: part 3</h4>
        <h1 class="no-margin"><em style="font-size: 92%">Simplification</em></h1>
        <ul>
          <li class="fragment">Consider onboarding and training costs of new tools</li>
          <li class="fragment">Use open source tools if a stable option exists</li>
          <li class="fragment">Write code that’s small and easy to delete</li>
          <li class="fragment">Build for now, not 5 years into the future</li>
        </ul>
        <aside class="notes">
          It can be tempting to build a project in, say, React, and then start
          adding tools: Redux, Thunk, Sagas, Recompose, and so on. But each of those
          tools adds extra complexity and cognitive overhead for the team. Don’t add
          a tool until you’ve got a real reason. If you definitely need a tool, look
          for a well-documented, stable, open source tool first; building stuff
          in-house means someone internal is on the hook to document, maintain, and
          support it, and that’s rarely a sustainable option for utilities. And
          don’t try to predict the future; code is a relatively short-lived product,
          so trying to build something “future-proof” is a bit of a fool’s errand.
          Code with deletion and replacement in mind, not infinite flexibility
          and scalability.

        </aside>
      </section>
      <section>
        <blockquote class="photo-quote">
          <div class="photo"><img src="./images/make-the-right-thing-the-easy-thing/jem-young.jpg" alt="Jem Young.">
          </div>
          <div class="quote">
            <p>“Weigh the trade-offs and choose the thing that makes your team more productive.”</p><strong>Jem
              Young<small>Senior Software Engineer, Netflix</small></strong>
          </div>
        </blockquote>
        <aside class="notes">
          Everything we do in our codebase has trade-offs. Jem recommends basing
          each decision on what will make the team most productive, even if that
          means skipping a tool that might logically be “more correct” because it’s
          too complicated to easily train the rest of the team.

        </aside>
      </section>
      <section>
        <blockquote class="photo-quote">
          <div class="photo"><img src="./images/make-the-right-thing-the-easy-thing/chris-biscardi.jpg"
              alt="Chris Biscardi."></div>
          <div class="quote">
            <p style="font-size: 78%">“Premature optimization can be a violent source of tech debt. If you have
              experience and know it’s the right move, great. Otherwise: keep it as simple as possible for as long as
              possible.”</p><strong>Chris Biscardi<small>Software Engineer, Honeycomb</small></strong>
          </div>
        </blockquote>
        <aside class="notes">
          In the spirit of trade-offs, “future-proofing” an app is making a
          trade-off. Adding a ton of “maybe we’ll need this someday” options is
          extra complexity now that may never actually be useful. But we also
          shouldn’t completely ignore the future when designing our projects — our
          job as lead developers is to find the right balance of keeping people
          productive now without ending up with tomorrow’s legacy nightmare. One way
          to do this is to emphasize writing easy-to-delete code: few dependencies,
          small size, and no side-effects.

        </aside>
      </section>
      <section>
        <h4 style="margin-bottom: 0.125em">Make the Right Thing the Easy Thing: part 4</h4>
        <h1 class="no-margin"><em style="font-size: 108%">Yak Shaving</em></h1>
        <ul>
          <li class="fragment">Limit the team’s exposure to yak shaving</li>
          <li class="fragment">Invest in your technical foundation</li>
          <li class="fragment">Create zero- or low-config dev environments</li>
        </ul>
        <aside class="notes">
          Probably the most important point, in my humble opinion, is to limit your
          team’s exposure to yak-shaving, which is all the terrible busywork we have
          to do <em>before</em> we can do our actual work. This means investing in our
          tech foundation to create solid dev environments and tooling to eliminate
          the need to do a ton of work just so they can start working.

        </aside>
      </section>
      <section>
        <h3>Don’t make people do a bunch of work before they can start working</h3>
        <aside class="notes">
          Yak shaving means all the work you have to do before you can start
          actually working. For example, if you need to mow the lawn, but you
          realize the lawn mower is out of gas, then discover that your gas can has
          a hole in it, you now have to go to the hardware store, then the gas
          station, all before you can even <em>begin</em> doing the original task.
          I can’t stress enough how important it is to invest in your team’s
          technical foundation. [Straw poll: how many of you lose at least an hour a
          week to fighting your dev environment (e.g. build tools, local envs,
          containers, deployment)?] [Tell IBM NGINX story.]

        </aside>
      </section>
      <section>
        <h3 style="font-size: 139%">2 hrs/week <span class="fragment">&times; 20 devs </span><span
            class="fragment">&times; $75k/year</span><strong class="fragment"
            style="display: block; font-size: 455%; line-height: 1">$75,000</strong><span class="fragment"
            style="font-size: 133%">burned on yak shaving</span></h3>
        <aside class="notes">
          If anyone tries to argue that working on the foundation doesn’t have
          anything to do with business needs, show them this math. Assuming a dev
          team of 20 people and using Glassdoor info for a salary baseline, just
          <em>two hours a week</em> of time spent on yak shaving costs $75,000 dollars.
          That’s an entire additional salary wasted on tasks that aren’t actually
          related to the company’s goals.

        </aside>
      </section>
      <section class="light-text dim"
        data-background-image="./images/make-the-right-thing-the-easy-thing/dumpster-fire.gif">
        <h2>Don’t ask people to <span class="underlined" style="display: block; font-size: 204%; line-height: 0.9">fix a
            mess</span></h2>
        <aside class="notes">
          Another reason to focus on the foundation is that we can enforce cultural
          norms through our boilerplates. If we provide a boilerplate with all the
          best practices baked into it, we’re changing the psychology of how our
          team interacts with our codebase. Instead of handing our team a blank
          slate (or worse, a pile of spaghetti code) and then asking them to fix it
          so it follows our team standards...

        </aside>
      </section>
      <section class="light-text dim"
        data-background-image="./images/make-the-right-thing-the-easy-thing/alley-oop.gif">
        <h2 style="font-size: 300%">Set them up to<span class="underlined"
            style="display: block; font-size: 187%; line-height: 0.9">succeed</span></h2>
        <aside class="notes">
          ...we should work to hand them well-built, thoroughly tested starters and
          boilerplates that already meet our standards. That way, all they have to
          do is keep it healthy and worry about <em>new</em> code. This appeals to our
          subconscious desire to keep nice things nice, and it helps steer the
          elephant in the direction of doing things The Right Way. We’re giving them
          the best possible chance of doing something awesome, demonstrated on this
          slide by these gentlemen playing sportsball.

        </aside>
      </section>
      <section>
        <h1 style="font-size: 470%">What is a <em style="display: block; font-size: 200%">Lead</em><span
            style="display: block; line-height: 0.65; font-size: 84%">Developer?</span></h1>
      </section>
      <section>
        <h2 style="font-size: 190%;">A lead developer <strong>isn’t</strong></h2>
        <ul>
          <li class="fragment">Carrying their team by doing most of the work</li>
          <li class="fragment">Inserting themself into every code decision</li>
          <li class="fragment">Single-handedly enforcing the team’s style guide</li>
        </ul>
      </section>
      <section>
        <h2 style="font-size: 190%;">A lead developer <em>is</em></h2>
        <ul>
          <li class="fragment">Creating guard rails to encourage best practices</li>
          <li class="fragment">Defining processes to create confidence and clarity</li>
          <li class="fragment">Removing bottlenecks and knowledge silos</li>
        </ul>
      </section>
      <section>
        <h2 class="no-margin">Lead Developers</h2>
        <h3 class="no-margin">Design processes that are <span class="underlined">emotionally rewarding</span></h3>
      </section>
      <section>
        <h2 class="no-margin">Lead Developers</h2>
        <h3 class="no-margin">Improve consistency by <span class="underlined">Automating processes</span></h3>
      </section>
      <section>
        <h2 class="no-margin">Lead Developers</h2>
        <h3 class="no-margin">Reduce training costs by <span class="underlined">simplifying workflows</span></h3>
      </section>
      <section>
        <h2 class="no-margin">Lead Developers</h2>
        <h3 class="no-margin">Invest in the foundation to <span class="underlined">Prevent yak shaving</span></h3>
      </section>
      <section>
        <h2 class="no-margin">Healthy Teams</h2>
        <h3 class="no-margin">Maintain a reasonable <span class="underlined">vacation tolerance</span></h3>
      </section>
      <section>
        <h2 class="no-margin">Healthy Teams</h2>
        <h3 class="no-margin">Operate with high levels of <span class="underlined">confidence &amp; clarity</span></h3>
      </section>
      <section>
        <h2 class="no-margin">Healthy Teams</h2>
        <h3 class="no-margin">Know their work is both <span class="underlined">recognized &amp; valued</span></h3>
      </section>
      <section>
        <h2 class="no-margin">Healthy Teams</h2>
        <h3 class="no-margin">Feel confident in their <span class="underlined">autonomy &amp; safety</span></h3>
      </section>
      <section>
        <h2 class="no-margin">Healthy Teams</h2>
        <h3 class="no-margin">Are not dependent on <span class="underlined">rockstar developers</span></h3>
      </section>
      <section>
        <h1 class="no-margin">Thanks!</h1><img src="./images/work-life-balance/jason-lengstorf.jpg"
          alt="Jason Lengstorf"
          style="display: block; background: #56453b; border-radius: 50%; width: 240px; min-width: 0; margin: 0 auto">
        <p style="margin-top: 0.25rem;">Jason Lengstorf<br><small>Follow me on Twitter: <a
              href="https://twitter.com/jlengstorf">@jlengstorf</a></small></p>
      </section>
      <section class="u--align-left resourcetext">
        <h4>Resources</h4>
        <ol>
          <li><a href="https://youtu.be/zqdCM8zR6Mc">“But Testing Sucks!” — How to Build a Testing- and Quality-Driven
              Culture</a></li>
          <li><a href="http://heathbrothers.com/books/switch/">Switch by Chip and Dan Heath</a></li>
          <li><a href="https://bit.ly/script-toolboxes">Kent C. Dodds on Script Toolboxes</a></li>
          <li><a href="https://twitter.com/marisamorby">Marisa Morby on Twitter</a></li>
          <li><a href="https://twitter.com/JemYoung">Jem Young on Twitter</a></li>
          <li><a href="https://twitter.com/chrisbiscardi">
              Chris Biscardi on Twitter
            </a></li>
        </ol>
      </section>
    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>
  <script>
    // We'll reference this element several times
    var htmlElement = document.querySelector('html');

    // Bind a function to the `fragmentshown` event so we can do some custom bits
    Reveal.addEventListener('fragmentshown', function (event) {
      var fragment = event.fragment;

      // For fragments with a `dim-the-lights` class, we dim the lights
      if (fragment.classList && fragment.classList.contains('dim-the-lights')) {
        htmlElement.classList.add('blackout');
      }
    });

    // Define a quick function to remove the blackout class from the document
    var removeBlackout = function removeBlackout() {
      return htmlElement.classList.remove('blackout');
    };

    // Bind the function to Reveal actions so we get the desired effect
    Reveal.addEventListener('fragmenthidden', removeBlackout);
    Reveal.addEventListener('slidechanged', removeBlackout);

    Reveal.addEventListener('slidechanged', event => {
      if (event.currentSlide.classList.contains('dim')) {
        htmlElement.classList.add('blackout');
      }
    });

    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      history: true,
      transition: 'none',
      backgroundTransition: 'none',

      // More info https://github.com/hakimel/reveal.js#dependencies
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
      ]
    });

  </script>
</body>

</html>